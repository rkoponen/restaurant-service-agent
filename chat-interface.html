<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Restaurant Agent - Streaming Chat</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Oxygen, Ubuntu, Cantarell, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 20px;
      }

      .container {
        background: white;
        border-radius: 16px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        width: 100%;
        max-width: 800px;
        height: 90vh;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      .header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 20px;
        text-align: center;
      }

      .header h1 {
        font-size: 24px;
        margin-bottom: 5px;
      }

      .header p {
        font-size: 14px;
        opacity: 0.9;
      }

      .chat-messages {
        flex: 1;
        overflow-y: auto;
        padding: 20px;
        background: #f5f5f5;
      }

      .message {
        margin-bottom: 16px;
        animation: slideIn 0.3s ease;
      }

      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .message-content {
        padding: 12px 16px;
        border-radius: 12px;
        max-width: 80%;
        word-wrap: break-word;
        line-height: 1.5;
      }

      .message.user {
        text-align: right;
      }

      .message.user .message-content {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        margin-left: auto;
      }

      .message.agent .message-content {
        background: white;
        color: #333;
        border: 1px solid #e0e0e0;
      }

      .message.agent .message-content.streaming {
        border-color: #667eea;
      }

      .typing-indicator {
        display: inline-block;
        padding: 12px 16px;
        background: white;
        border: 1px solid #e0e0e0;
        border-radius: 12px;
      }

      .typing-indicator span {
        height: 8px;
        width: 8px;
        background: #667eea;
        border-radius: 50%;
        display: inline-block;
        margin: 0 2px;
        animation: bounce 1.4s infinite ease-in-out both;
      }

      .typing-indicator span:nth-child(1) {
        animation-delay: -0.32s;
      }

      .typing-indicator span:nth-child(2) {
        animation-delay: -0.16s;
      }

      @keyframes bounce {
        0%,
        80%,
        100% {
          transform: scale(0);
        }
        40% {
          transform: scale(1);
        }
      }

      .input-area {
        padding: 20px;
        background: white;
        border-top: 1px solid #e0e0e0;
      }

      .input-wrapper {
        display: flex;
        gap: 10px;
      }

      #messageInput {
        flex: 1;
        padding: 12px 16px;
        border: 2px solid #e0e0e0;
        border-radius: 24px;
        font-size: 14px;
        outline: none;
        transition: border-color 0.3s;
      }

      #messageInput:focus {
        border-color: #667eea;
      }

      #sendButton {
        padding: 12px 32px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 24px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s, box-shadow 0.2s;
      }

      #sendButton:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
      }

      #sendButton:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .session-info {
        padding: 10px 20px;
        background: #f0f0f0;
        border-bottom: 1px solid #e0e0e0;
        font-size: 12px;
        color: #666;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .controls {
        display: flex;
        gap: 10px;
        align-items: center;
      }

      .tts-toggle {
        padding: 6px 12px;
        background: #667eea;
        color: white;
        border: none;
        border-radius: 12px;
        font-size: 11px;
        cursor: pointer;
        transition: opacity 0.2s;
      }

      .tts-toggle:hover {
        opacity: 0.8;
      }

      .tts-toggle.disabled {
        background: #ccc;
      }

      .speaker-icon {
        font-size: 16px;
      }

      .stt-toggle {
        padding: 6px 12px;
        background: #764ba2;
        color: white;
        border: none;
        border-radius: 12px;
        font-size: 11px;
        cursor: pointer;
        transition: opacity 0.2s;
      }

      .stt-toggle:hover {
        opacity: 0.8;
      }

      .stt-toggle.listening {
        background: #e74c3c;
        animation: pulse 1.5s infinite;
      }

      .stt-toggle.disabled {
        background: #ccc;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.6;
        }
      }

      .mic-button {
        padding: 12px 20px;
        background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        color: white;
        border: none;
        border-radius: 24px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s, box-shadow 0.2s;
      }

      .mic-button:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(231, 76, 60, 0.4);
      }

      .mic-button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .mic-button.listening {
        background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
        animation: pulse 1.5s infinite;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>Car Agent</h1>
        <!-- <p>Streaming AI-powered customer service</p> -->
      </div>

      <div class="session-info">
        <span>Session ID: <strong id="sessionId"></strong></span>
        <div class="controls">
          <button
            id="sttToggle"
            class="stt-toggle"
            title="Toggle Speech-to-Text"
          >
            ðŸŽ¤ STT: OFF
          </button>
          <button
            id="ttsToggle"
            class="tts-toggle"
            title="Toggle Text-to-Speech"
          >
            <span class="speaker-icon">ðŸ”Š</span> TTS: ON
          </button>
        </div>
      </div>

      <div class="chat-messages" id="chatMessages"></div>

      <div class="input-area">
        <div class="input-wrapper">
          <button id="micButton" class="mic-button" title="Hold to speak">
            ðŸŽ¤ Hold to Speak
          </button>
          <input
            type="text"
            id="messageInput"
            placeholder="Type your message... (e.g., 'I'd like to make a reservation')"
            autocomplete="off"
          />
          <button id="sendButton">Send</button>
        </div>
      </div>
    </div>

    <script>
      // Generate a unique session ID for this chat session
      const sessionId =
        "session-" + Date.now() + "-" + Math.random().toString(36).substr(2, 9);
      document.getElementById("sessionId").textContent = sessionId;

      const chatMessages = document.getElementById("chatMessages");
      const messageInput = document.getElementById("messageInput");
      const sendButton = document.getElementById("sendButton");
      const ttsToggle = document.getElementById("ttsToggle");
      const sttToggle = document.getElementById("sttToggle");
      const micButton = document.getElementById("micButton");

      let isStreaming = false;
      let ttsEnabled = true;
      let sttEnabled = false;
      let speechSynthesis = window.speechSynthesis;
      let currentUtterance = null;

      // Speech recognition setup
      let recognition = null;
      let isListening = false;
      let silenceTimer = null;
      let interimTranscript = "";
      let finalTranscript = "";

      if ("webkitSpeechRecognition" in window) {
        recognition = new webkitSpeechRecognition();
      } else if ("SpeechRecognition" in window) {
        recognition = new SpeechRecognition();
      }

      if (recognition) {
        recognition.continuous = true;
        recognition.interimResults = true;
        recognition.lang = "en-US";
      }

      function addMessage(content, isUser = false) {
        const messageDiv = document.createElement("div");
        messageDiv.className = `message ${isUser ? "user" : "agent"}`;

        const contentDiv = document.createElement("div");
        contentDiv.className = "message-content";
        contentDiv.textContent = content;

        messageDiv.appendChild(contentDiv);
        chatMessages.appendChild(messageDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;

        return contentDiv;
      }

      function showTypingIndicator() {
        const messageDiv = document.createElement("div");
        messageDiv.className = "message agent";
        messageDiv.id = "typing-indicator";

        const typingDiv = document.createElement("div");
        typingDiv.className = "typing-indicator";
        typingDiv.innerHTML = "<span></span><span></span><span></span>";

        messageDiv.appendChild(typingDiv);
        chatMessages.appendChild(messageDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }

      function removeTypingIndicator() {
        const indicator = document.getElementById("typing-indicator");
        if (indicator) {
          indicator.remove();
        }
      }

      // Text-to-Speech functions
      let speechQueue = [];
      let isSpeaking = false;
      let lastSpokenLength = 0;

      function speakNext() {
        if (speechQueue.length === 0) {
          isSpeaking = false;
          return;
        }

        isSpeaking = true;
        const text = speechQueue.shift();

        const utterance = new SpeechSynthesisUtterance(text);
        utterance.rate = 1.1;
        utterance.pitch = 1.0;
        utterance.volume = 1.0;

        // Optional: Select a specific voice
        const voices = speechSynthesis.getVoices();
        const preferredVoice =
          voices.find(
            (voice) =>
              voice.lang.startsWith("en") && voice.name.includes("Female")
          ) || voices.find((voice) => voice.lang.startsWith("en"));

        if (preferredVoice) {
          utterance.voice = preferredVoice;
        }

        utterance.onend = () => {
          speakNext();
        };

        utterance.onerror = () => {
          speakNext();
        };

        speechSynthesis.speak(utterance);
      }

      function speakChunk(text) {
        if (!ttsEnabled || !text) return;

        speechQueue.push(text);

        if (!isSpeaking) {
          speakNext();
        }
      }

      function speak(text) {
        if (!ttsEnabled || !text) return;

        const utterance = new SpeechSynthesisUtterance(text);
        utterance.rate = 1.1;
        utterance.pitch = 1.0;
        utterance.volume = 1.0;

        const voices = speechSynthesis.getVoices();
        const preferredVoice =
          voices.find(
            (voice) =>
              voice.lang.startsWith("en") && voice.name.includes("Female")
          ) || voices.find((voice) => voice.lang.startsWith("en"));

        if (preferredVoice) {
          utterance.voice = preferredVoice;
        }

        speechSynthesis.speak(utterance);
      }

      function stopSpeaking() {
        speechQueue = [];
        isSpeaking = false;
        lastSpokenLength = 0;
        if (speechSynthesis.speaking) {
          speechSynthesis.cancel();
        }
      }

      function extractCompleteSentences(text, lastIndex) {
        // Extract complete sentences or phrases from the new text
        const newText = text.slice(lastIndex);
        const sentenceEndings = /[.!?]\s+/g;
        let match;
        let lastEndIndex = 0;
        const chunks = [];

        while ((match = sentenceEndings.exec(newText)) !== null) {
          const sentence = newText
            .slice(lastEndIndex, match.index + match[0].length)
            .trim();
          if (sentence) {
            chunks.push(sentence);
          }
          lastEndIndex = match.index + match[0].length;
        }

        return {
          chunks,
          newLastIndex: lastIndex + lastEndIndex,
        };
      }

      // Speech Recognition Functions
      function startListening() {
        if (!recognition || !sttEnabled) return;

        isListening = true;
        finalTranscript = "";
        interimTranscript = "";
        micButton.classList.add("listening");
        micButton.innerHTML = "ðŸŽ¤ Listening...";
        messageInput.placeholder = "Listening...";

        recognition.start();
      }

      function stopListening() {
        if (!recognition || !isListening) return;

        isListening = false;
        micButton.classList.remove("listening");
        micButton.innerHTML = "ðŸŽ¤ Hold to Speak";
        messageInput.placeholder =
          "Type your message... (e.g., 'I'd like to make a reservation')";

        clearTimeout(silenceTimer);
        recognition.stop();
      }

      if (recognition) {
        recognition.onresult = (event) => {
          interimTranscript = "";

          for (let i = event.resultIndex; i < event.results.length; i++) {
            const transcript = event.results[i][0].transcript;

            if (event.results[i].isFinal) {
              finalTranscript += transcript + " ";
            } else {
              interimTranscript += transcript;
            }
          }

          // Update input field with current transcript
          messageInput.value = (finalTranscript + interimTranscript).trim();

          // Reset silence timer - send after 2 seconds of silence
          clearTimeout(silenceTimer);
          silenceTimer = setTimeout(() => {
            if (finalTranscript.trim() || interimTranscript.trim()) {
              stopListening();
              // Automatically send the message after 2 seconds of silence
              if (messageInput.value.trim()) {
                sendMessage();
              }
            }
          }, 2000);
        };

        recognition.onerror = (event) => {
          console.error("Speech recognition error:", event.error);
          stopListening();
        };

        recognition.onend = () => {
          if (isListening) {
            // Restart if still supposed to be listening
            recognition.start();
          }
        };
      }

      // Toggle STT
      sttToggle.addEventListener("click", () => {
        if (!recognition) {
          alert(
            "Speech recognition is not supported in your browser. Please use Chrome, Edge, or Safari."
          );
          return;
        }

        sttEnabled = !sttEnabled;
        sttToggle.innerHTML = sttEnabled ? "ðŸŽ¤ STT: ON" : "ðŸŽ¤ STT: OFF";
        sttToggle.classList.toggle("disabled", !sttEnabled);

        if (!sttEnabled && isListening) {
          stopListening();
        }

        micButton.style.display = sttEnabled ? "block" : "none";
      });

      // Mic button - hold to speak
      micButton.addEventListener("mousedown", () => {
        if (!sttEnabled || isStreaming) return;
        startListening();
      });

      micButton.addEventListener("mouseup", () => {
        // Don't stop immediately on mouseup, let the silence timer handle it
      });

      micButton.addEventListener("mouseleave", () => {
        // If mouse leaves button while holding, stop listening
        if (isListening) {
          stopListening();
        }
      });

      // Touch support for mobile
      micButton.addEventListener("touchstart", (e) => {
        e.preventDefault();
        if (!sttEnabled || isStreaming) return;
        startListening();
      });

      micButton.addEventListener("touchend", (e) => {
        e.preventDefault();
        // Don't stop immediately, let the silence timer handle it
      });

      // Toggle TTS
      ttsToggle.addEventListener("click", () => {
        ttsEnabled = !ttsEnabled;
        ttsToggle.innerHTML = ttsEnabled
          ? '<span class="speaker-icon">ðŸ”Š</span> TTS: ON'
          : '<span class="speaker-icon">ðŸ”‡</span> TTS: OFF';
        ttsToggle.classList.toggle("disabled", !ttsEnabled);

        if (!ttsEnabled) {
          stopSpeaking();
        }
      });

      // Stop speaking when user starts typing a new message
      messageInput.addEventListener("focus", () => {
        if (isStreaming) {
          stopSpeaking();
        }
      });

      async function sendMessage() {
        const message = messageInput.value.trim();
        if (!message || isStreaming) return;

        // Add user message to chat
        addMessage(message, true);
        messageInput.value = "";

        // Show typing indicator
        showTypingIndicator();

        // Disable input
        isStreaming = true;
        sendButton.disabled = true;
        messageInput.disabled = true;

        try {
          // Use relative URL for deployment compatibility
          const apiUrl =
            window.location.hostname === "localhost"
              ? "http://localhost:8000/chat/stream"
              : "/chat/stream";

          const response = await fetch(apiUrl, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              message: message,
              sessionId: sessionId,
            }),
          });

          if (!response.ok) {
            throw new Error("Network response was not ok");
          }

          // Remove typing indicator before streaming
          removeTypingIndicator();

          // Create a message element for the streaming response
          const agentMessageDiv = document.createElement("div");
          agentMessageDiv.className = "message agent";
          const contentDiv = document.createElement("div");
          contentDiv.className = "message-content streaming";
          agentMessageDiv.appendChild(contentDiv);
          chatMessages.appendChild(agentMessageDiv);

          // Read the stream
          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let buffer = "";
          let fullContent = "";
          lastSpokenLength = 0; // Reset for new message

          while (true) {
            const { done, value } = await reader.read();

            if (done) break;

            buffer += decoder.decode(value, { stream: true });
            const lines = buffer.split("\n");
            buffer = lines.pop() || "";

            for (const line of lines) {
              if (line.startsWith("data: ")) {
                const data = JSON.parse(line.slice(6));

                if (data.content) {
                  // Append new token to full content instead of replacing
                  fullContent += data.content;
                  contentDiv.textContent = fullContent;
                  chatMessages.scrollTop = chatMessages.scrollHeight;

                  // Extract and speak complete sentences as they arrive
                  const result = extractCompleteSentences(
                    fullContent,
                    lastSpokenLength
                  );
                  if (result.chunks.length > 0) {
                    result.chunks.forEach((chunk) => speakChunk(chunk));
                    lastSpokenLength = result.newLastIndex;
                  }
                }

                if (data.done) {
                  contentDiv.classList.remove("streaming");
                  // Speak any remaining text that wasn't a complete sentence
                  if (lastSpokenLength < fullContent.length) {
                    const remaining = fullContent
                      .slice(lastSpokenLength)
                      .trim();
                    if (remaining) {
                      speakChunk(remaining);
                    }
                  }
                }

                if (data.error) {
                  contentDiv.textContent = "Error: " + data.error;
                  contentDiv.style.color = "red";
                }
              }
            }
          }
        } catch (error) {
          removeTypingIndicator();
          console.error("Error:", error);
          const errorDiv = addMessage(
            "Sorry, there was an error connecting to the server.",
            false
          );
          errorDiv.style.color = "red";
        } finally {
          // Re-enable input
          isStreaming = false;
          sendButton.disabled = false;
          messageInput.disabled = false;
          messageInput.focus();
        }
      }

      // Event listeners
      sendButton.addEventListener("click", sendMessage);

      messageInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          sendMessage();
        }
      });

      // Add welcome message
      //   setTimeout(() => {
      //     const welcomeMsg =
      //       "Hello! Welcome to our restaurant. How can I help you today?";
      //     addMessage(welcomeMsg, false);
      //     speak(welcomeMsg);
      //   }, 500);

      // Load voices (needed for some browsers)
      if (speechSynthesis.onvoiceschanged !== undefined) {
        speechSynthesis.onvoiceschanged = () => {
          speechSynthesis.getVoices();
        };
      }

      // Hide mic button initially (STT is off by default)
      micButton.style.display = "none";

      // Focus input on load
      messageInput.focus();
    </script>
  </body>
</html>
